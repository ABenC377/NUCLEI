

___Lexical parser testing___

The following functions are assert tested in the lexical_parse_test() function as described:
- update_tokens()
    This function takes in the pre-made token-list, FSM automata, and a character.  The behavious is dictated by the state of the automata, and c.  Therefore, I test it with an automata in every state, and for each state, each type of character (e.g., each type of expected character, and imaginable unexpected characters).

- add_previous_chars()
    This function is for backtracking when you have already recieved a number of letters of a reserved word (e.g., WHILE) and then recieved an unexpected character.  It does this by adding the first letter of the reserved word as a variable token to the token list, and the considering the following letters in order as if they were newly input characters.  To test this function, I checked that the function correctly adds the variable to a token list, and then seperately that it correctly adds the following characters (either as variables or as different reserved words).

- make_and_add_simple_token()
    

- add_variable_token()
    

- handle_start_state()
    

- add_token()
    


The following functions rely on command line arguments and reading from files, and so are not testable with quiet assert testing:
- run_lexiacl_analyser()
- get_file_name()
- check_inputs()
- get_tokens_from_file()

The following functions are structure-specific print functions, and are only used for debugging etc., so are not testable with quiet assert testing:
- print_tokens()
- print_token()

The following functions are used in the lexical_parse_test() function, but are not directly assert tested.  However, they free the memory allocated to the structures made for testing the other functions, and using Valgrind it is seen that running lexical_parse_test() does not result in any memory leaks.  Therefore, we can see that these functions work as intended:
- free_token_list()
- free_token_node()